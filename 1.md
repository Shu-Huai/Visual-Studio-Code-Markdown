# 软件工程

## 软件工程学概述

### 软件危机

在计算机软件的开发和维护过程中所遇到的一系列严重问题

#### 问题

- 如何开发软件，以满足对软件日益增长的需求

- 如何维护数量不断膨胀的已有软件

#### 表现

- 对软件开发成本和进度的估计常常很不准确

- 用户对已完成的软件系统不满意的现象经常发生

- 软件产品的质量往往靠不住

- 软件常常是不可维护的

- 软件通常没有适当的文档资料

- 软件成本在计算机系统总成本中所占的比例逐年上升

- 软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势

#### 原因

本身特点

开发与维护的方法不正确

#### 消除

- 彻底消除“软件就是程序”的错误观念。
一个软件必须由一个完整的配置组成，事实上，软件是程序、数据及相关文档的完整集合。文档是开发、使用和维护程序所需要的图文资料。

- 充分认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目，不是个人独立的劳动。

- 推广和使用在实践中总结出来的软件开发的成功技术和方法。

- 开发和使用更好的软件工具

### 软件工程

#### 软件工程的介绍

软件工程是指导计算机软件开发和维护的一门工程学科

采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。

##### 本质特征

- 软件工程关注于大型程序的构造。

- 软件工程的中心课题是控制复杂性。

- 软件经常变化。

- 开发软件的效率非常重要。

- 和谐地合作是开发软件的关键。

- 软件必须有效地支持它的用户。

- 在软件工程领域中通常由具有一种文化背景的人替具有另一种文化背景的人创造产品。

##### 软件工程的基本原理

- 用分阶段的生命周期计划严格管理

- 坚持进行阶段评审

- 实行严格的产品控制

- 采用现代程序设计技术

- 结果应能清楚地审查

- 开发小组的人员应该少而精

- 承认不断改进软件工程实践的必要性

##### 软件工程方法学

三个要素：方法、工具、过程

- 工具
为软件工程方法提供自动或半自动的软件支撑环境

- 方法
完成软件开发的各项任务的技术方法

- 过程
规定了完成各项任务的工作步骤

##### 传统方法学

##### 面向对象方法学

### 软件生命周期

概括来说，软件生命周期由软件定义、软件开发和软件维护三个阶段组成。

#### 软件定义

确定软件开发工程必须完成的总目标

确定工程的可行性

导出实现工程目标应该采用的策略及系统必须完成的功能

估计完成该项工程需要的资源和成本，并且制定工程进度表

#### 软件开发

具体设计和实现在前一个时期定义的软件

总体设计

详细设计

编码和单元测试

综合测试

#### 运行维护

使软件持久地满足用户的需要

#### 问题定义

要解决的问题是什么。

确定用户要求解决的性质、工程的目标和规模。

#### 可行性分析

对于上一个阶段所确定的问题有行得通的解决方法吗。

经济可行性、技术可行性、法律可行性

#### 需求分析

为了解决这个问题，目标系统必须要做什么。

确定系统必须具有的功能和性能，系统要求的运行环境，并且预测系统发展的前景。

#### 总体设计

概括地说，应该怎样实现目标系统。

设计出实现目标系统的几种可能的方案。推荐一个最佳方案。

#### 详细设计

应该怎样具体地实现这个系统呢。

设计出程序的详细规格说明

#### 编码和单元测试

写出正确的容易理解、容易维护的程序模块。

仔细测试编写出的每一个模块。

#### 综合测试

通过各种类型的测试使软件达到预定的要求。

集成测试

验收测试

现场测试

平行运行

#### 软件维护

通过各种必要的维护活动使系统持久地满足用户的需要。

改正性维护
诊断和改正在使用过程中发现的软件错误

适应性维护
修改软件以适应环境的变化

完善性维护
根据用户的要求改进或扩充软件使它更完善

预防性维护
修改软件，为将来的维护预先做准备

### 软件过程

#### 生命周期模型

生命周期模型规定了把生命周期划分成哪些阶段及各个阶段的执行顺序，因此，也称为过程模型。

#### 瀑布模型

阶段间具有顺序性和依赖性

推迟实现的观点

质量保证的观点
每个阶段都必须完成规定的文档
每个阶段结束前都要对所完成的文档进行评审

![快速原型模型](http://shu-huai.cn:13127/public/图床/瀑布模型.png "瀑布模型")

优点

- 可强迫开发人员采用规范的方法

- 严格地规定了每个阶段必须提交的文档

- 要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证

缺点

- 开发过程一般不能逆转，否则代价太大。软件的实际情况必须到项目开发后期才能看到。

- 无法解决软件需求不明确或不准确的问题；可能导致最终开发的产品不能真正满足用户需要。

#### 快速原型模型

快速建立一个能反映用户主要需求的原型系统

![瀑布模型](http://shu-huai.cn:13127/public/图床/快速原型模型.png "快速原型模型")

原型系统通过与用户的交互而得到验证

#### 增量模型

![增量模型](http://shu-huai.cn:13127/public/图床/增量模型.png "增量模型")

把软件产品作为一系列的增量构件来设计、编码、继承和测试

![增量模型2](http://shu-huai.cn:13127/public/图床/增量模型2.png "增量模型2")

#### 螺旋模型

每个阶段之前都增加了风险分析过程

![螺旋模型](http://shu-huai.cn:13127/public/图床/螺旋模型.png "螺旋模型")

确定阶段目标，选择方案，设定约束条件。

风险分析，排除风险。

开发。

评价阶段成果，计划下一阶段的工作。

优点

- 对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标

- 减少了过多测试或测试不足所带来的风险

- 在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别

## 可行性研究

### 可行性研究的任务

- 技术可行性
使用现有的技术能实现这个系统吗？

- 经济可行性
这个系统的经济效益能超过它的开发成本吗？

- 操作可行性
系统的操作方式在这个用户组织内行得通吗？

### 可行性研究过程

![可行性研究过程](http://shu-huai.cn:13127/public/图床/可行性研究过程.png "可行性研究过程")

### 系统流程图

系统流程图是概括地描绘物理系统的传统工具。

用图形符号以黑盒子形式描绘组成系统的每个部件。

![系统流程图1](http://shu-huai.cn:13127/public/图床/系统流程图1.png "系统流程图1")

![系统流程图2](http://shu-huai.cn:13127/public/图床/系统流程图2.png "系统流程图2")

例
某装配厂有一座存放零件的仓库，仓库中现有各种零件的数量和每种零件的库存临界值等数据存放在库存清单主文件中。当仓库中零件数量有变化时，应及时修改库存清单主文件，如果哪种零件的库存量少于它的库存量临界值，则应该报告给采购部门以便定货，规定每天向采购部门送一次定货报告。
![系统流程图3](http://shu-huai.cn:13127/public/图床/系统流程图3.png "系统流程图3")

### 数据流图

数据流图中没有具体的物理元素，用于描绘数据在系统中流动和被处理的逻辑过程。

![数据流图1](http://shu-huai.cn:13127/public/图床/数据流图1.png "数据流图1")

例

![数据流图2](http://shu-huai.cn:13127/public/图床/数据流图2.png "数据流图2")

#### 分层

![数据流图3](http://shu-huai.cn:13127/public/图床/数据流图3.png "数据流图3")

#### 步骤

1. 画系统的输入和输出（顶层图）
把整个软件系统看作一个大的加工，确定软件的数据源点和终点、源点和终点与软件系统之间的输入/输出数据流

2. 画系统的内部（0层图）
分解顶层图中的加工，并用数据流将这些加工连接起来，使得顶层图中的输入数据流经一连串的加工处理后变换成顶层图的输出数据流
在数据流的组成或值发生变化的地方应画一个加工，这个加工的功能就是实现这一变化
也可根据系统的功能确定加工

3. 画加工的内部
把每个加工看作一个小系统，该加工的输入输出数据流看成小系统的输入输出数据流
用画0层图同样的方法画出每个加工的DFD子图

4. 对第3步分解出来的DFD子图中的每个加工重复第3步的分解

#### 分层数据流图的正确性检查

子图与父图的平衡

加工的数据守恒

文件的画法

例

某考务处理系统有如下功能：
对考生送来的报名单进行检查；
对合格的报名单编好准考证号后将准考证送给考生，并将汇总后的考生名单送给阅卷站；
对阅卷站送来的成绩清单进行检查，并根据考试中心制定的合格标准审定合格者；
制作考生通知单（内含成绩及合格／不合格标志）送给考生；
按地区、年龄、文化程度、职业、考试级别等进行成绩分类统计和试题难度分析，产生统计分析表。
顶层图
![数据流图4](http://shu-huai.cn:13127/public/图床/数据流图4.png "数据流图4")
0层图
![数据流图5](http://shu-huai.cn:13127/public/图床/数据流图5.png "数据流图5")
一层图
![数据流图6](http://shu-huai.cn:13127/public/图床/数据流图6.png "数据流图6")
![数据流图7](http://shu-huai.cn:13127/public/图床/数据流图7.png "数据流图7")

### 数据字典

数据字典是对数据流图中包含的所有元素的定义的集合。

#### 内容

- 数据项

- 数据流

- 数据存储

- 处理

#### 由数据元素组成数据的方式的三种基本类型

顺序 `$$+$$`

选择 `$$[│]$$`

重复 `$$\{\}$$`

可选 `$$()$$`

常常使用上限和下限进一步注释表示重复的花括弧。一种注释方法是在开括弧的左边用上角标和下角标分别表明重复的上限和下限；另一种注释方法是在开括弧左侧标明重复的下限，在闭括弧的右侧标明重复的上限。
`$$_1^5\{A\}$$`和`$$1\{A\}5$$`

例
![数据字典](http://shu-huai.cn:13127/public/图床/数据字典.png "数据字典")
`$$存折=户名+所号+账号+开户日+性质+印密+1\{存取条目\}5$$`
`$$户名=1\{字母\}24$$`
`$$所号="001"\cdots "999"$$`
`$$帐号="00000001"\cdots "99999999"$$`
`$$开户日=年+月+日$$`
`$$性质="1"\cdots "6"$$`
`$$印密="0"$$`
`$$存取条目=日期+摘要+支出+收入+余额+操作+复核$$`

### 数据流图例

图书预订系统：书店向顾客发放订单，顾客将所填订单交由系统处理，系统首先依据图书目录对订单进行检查并对合格订单进行处理，处理过程中根据顾客情况和订单数目将订单分为优先订单与正常订单两种，随时处理优先订单，定期处理正常订单。最后系统根据所处理的订单汇总，并按出版社要求发给出版社。
![数据流图8](http://shu-huai.cn:13127/public/图床/数据流图8.png "数据流图8")
![数据流图9](http://shu-huai.cn:13127/public/图床/数据流图9.png "数据流图9")
![数据流图10](http://shu-huai.cn:13127/public/图床/数据流图10.png "数据流图10")

## 需求分析

### 需求分析的任务

- 分析系统的综合要求
功能需求、性能需求、可靠性和可用性需求、出错处理需求、接口需求、约束、逆向需求、将来可能提出的要求

- 分析系统的数据要求
建立数据模型

- 导出系统的逻辑模型
数据流图、实体-联系图、状态转换图、数据字典和主要的处理算法

- 修正系统开发计划

### 与用户沟通获取需求的方法

访谈、面向数据流自顶向下求精、简易的应用规格说明技术、快速建立软件模型

### 分析建模与规格说明

分析建模
数据模型（实体-联系图）、功能模型（数据流图）、行为模型（状态转换图）

软件需求规格说明

### 实体-联系图

#### 数据对象

对软件必须理解的符合信息的抽象

可以由一组属性来定义的实体

数据对象彼此间有关联

只有数据没有对数据上的操作

#### 属性

数据对象的性质

关键字、键、标识符

#### 联系

数据对象彼此之间相互连接的方式

- 一对一联系（1:1）

- 一对多联系（1:N）

- 多对多联系（M:N）

#### 符号

- 矩形框代表实体

- 菱形框表示关系

- 椭圆形或圆角矩形表示实体的属性

- 用直线把实体与其属性连接起来

例
某校教学管理ER图
![ER图](http://shu-huai.cn:13127/public/图床/ER图.png "ER图")

### 状态转换图

通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。

#### 状态

初态（即初始状态）、终态（即最终状态）和中间状态

#### 事件

引起系统做动作或转换状态的控制信息

#### 符号

- 初态：实心圆

- 终态：同心圆

- 中间状态：圆角矩形

上面为名称，中间是状态变量的名字和值，下面是活动表

活动表：事件名(参数表)/动作表达式
常用entry、exit和do

两个状态之间的连线是状态转换，在上面写事件表达式
事件表达式：事件说明[守卫条件]/动作表达式
事件说明：事件名(参数表)
![状态转换图1](http://shu-huai.cn:13127/public/图床/状态转换图1.png "状态转换图1")

例
电话的状态图
![状态转换图2](http://shu-huai.cn:13127/public/图床/状态转换图2.png "状态转换图2")

### 其他图形工具

#### 层次方框图

![层次方框图](http://shu-huai.cn:13127/public/图床/层次方框图.png "层次方框图")

#### Warnier图

![Warnier图](http://shu-huai.cn:13127/public/图床/Warnier图.png "Warnier图")

#### IPO图

![IPO图](http://shu-huai.cn:13127/public/图床/IPO图.png "IPO图")

![IPO表](http://shu-huai.cn:13127/public/图床/IPO表.png "IPO表")

### 验证软件需求

从四个方面验证

- 一致性
所有的需求必须是一致的，任何一条需求不能和其他需求互相矛盾。
采用形式化需求陈述语言书写。

- 完整性
需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。
使用原型系统，和客户密切合作。

- 现实性
指定的需求应该使用现有的硬件技术和软件技术基本上可以实现的。
根据过往开发经验，必要时使用仿真技术。

- 有效性
必须证明需求是正确有效的，确实能解决用户面对的问题。
使用原型系统，和客户密切合作。

## 形式化说明技术

### 概述

非形式化方法的缺点：矛盾、二义性、含糊性、不完整性、抽象层次混乱

## 总体设计

### 设计过程

- 设想供选择的方案

- 选取合理的方案

- 推荐最佳方案

- 功能分解

- 设计软件结构

- 设计数据库

- 指定测试计划

- 书写文档

- 审查和复审

### 设计原理

#### 模块化

把程序划分成独立命名且可独立访问的模块

- 模块
数据说明、可执行语句等程序对象的集合
可以单独命名且可通过名字来访问
由两部分构成

- 内部特性
指完成其功能的程序代码和仅供该模块内部使用的数据。

- 外部特性
指模块名和参数表（输入参数、输出参数），以及对程序及整个系统造成的影响。

- 抽象

- 逐步求精
为了能集中精力解决主要问题而尽量推迟对问题细节的考虑

- 信息隐藏和局部化
- 信息隐藏
应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。

- 局部化
把一些关系密切的软件元素物理地放得彼此靠近。

- 模块独立
高内聚、低耦合

- 耦合
  - 数据耦合

  - 特征耦合

  - 控制耦合

  - 公共环境耦合

  - 内容耦合

- 内聚
  - 功能内聚
所有处理元素属于一个整体，完成一个单一的功能。

  - 顺序内聚
模块中所有处理元素和同一个功能密切相关，且这些处理必须顺序执行。

  - 通信内聚
模块中所有元素都使用同一个输入数据，和/或产生同一个输出数据。

  - 过程内聚
模块内的处理元素是相关的，且必须以特定次序执行。

  - 时间内聚
若干个任务必须在同一段时间内执行。如初始化工作。

  - 逻辑内聚
若干个逻辑功能类似的任务组成一个模块。

  - 偶然内聚
一个模块完成一组任务，任务之间的关系很松散。

    ![内聚](http://shu-huai.cn:13127/public/图床/内聚.png "内聚")

### 启发规则

- 改进软件结构，力求提高模块独立性
模块分解或合并，力求降低耦合提高内聚

- 模块的规模应当适中
分解不应该降低模块独立性
模块的可理解与接口的复杂性的矛盾统一

- 深度、宽度、扇出和扇入都应适当

- 模块的判定的作用域应当在控制域之内

- 力求降低模块接口复杂性

- 设计单入口单出口的模块

- 模块的功能应该可以预测

### 描绘软件结构的图形工具

#### 层次图

![层次图](http://shu-huai.cn:13127/public/图床/层次图.png "层次图")

#### 结构图

![结构图](http://shu-huai.cn:13127/public/图床/结构图.png "结构图")

### 面向数据流的设计方法

#### 变换流

进入系统的信息通过变换中心，经过加工后再沿输出通路变为外部形式离开系统

#### 事物流

以事物为中心

#### 设计过程

![面向数据流的设计方法](http://shu-huai.cn:13127/public/图床/面向数据流的设计方法.png "面向数据流的设计方法")

## 详细设计

### 任务

详细设计是给出软件结构中各模块的内部过程描述。

模块的内部过程描述也就是模块内部的算法设计。

详细设计也既是要导出一种算法设计表示，由此可以直接而简单地导出程序代码。

### 结构程序设计

顺序、分支和循环三种基本控制结构和程序块只有“一个入口和一个出口”的原则

结构程序设计是避免用GOTO语句的一种程序设计

结构程序设计是自顶向下的程序设计

结构程序设计是一种组织和编制程序的方法,利用它编制的程序是容易理解和容易修改的

程序结构化的一个主要功能是使得正确性的证明容易实现

特点

- 结构清晰

- 容易阅读

- 容易修改

- 容易验证

### 人机界面设计

#### 设计问题

系统响应时间

用户帮助设施

出错信息处理

命令交互

#### 设计过程

迭代

#### 人机界面设计指南

一般交互指南

- 保持一致性

- 提供有意义的反馈

- 在执行有较大破坏性的动作之前要求用户确认

- 允许取消绝大多数操作

- 减少在两次操作之间必须记忆的信息量

- 提高对话、移动和思考的效率

- 允许犯错误

- 按功能对动作分类

- 提供对用户工作内容敏感的帮助设施

- 用简单动词或动词短语作为命令名

信息显示指南

- 只显示与当前工作内容有关的信息

- 不要用数据淹没用户

- 使用一致的标记、标准的缩写和可预知的颜色

- 允许用户保持可视化的语境

- 产生有意义的出错信息

- 使用大小写、缩进和文本分组以帮助理解

- 使用窗口分隔不同类型的信息

- 使用模拟显示方式表示信息

- 高效率地使用显示屏

数据输入指南

- 尽量前哨用户的输入动作

- 保持信息显示和数据输入之间的一致性

- 允许用户自定义输入

- 交互应该是灵活的

- 使在当前动作语境中不适用的命令不起作用

- 让用户控制交互流

- 对所有输入动作都提供帮助

- 消除冗余的输入

### 过程设计的工具

#### 图形工具

- 程序流程图
优点
直观、容易掌握，且历史“悠久”，使用广泛。
缺点
本质上不具备逐步求精的特点，对于提高大型系统的可理解性作用甚微；不易表示数据结构；转移控制太方便。
![程序流程图1](http://shu-huai.cn:13127/public/图床/程序流程图1.png "程序流程图1")
例
求`$$ax^2+bx+c=0$$`之根`$$(a\ne0)$$`
![程序流程图2](http://shu-huai.cn:13127/public/图床/程序流程图2.png "程序流程图2")

- 盒图
特点
功能域明确，可以从盒图上一眼看出来
不可能任意转移控制
很容易确定局部和全程数据的作用域
很容易表现嵌套关系，也可以表示模块的层次结构
![盒图1](http://shu-huai.cn:13127/public/图床/盒图1.png "盒图1")
例
求`$$ax^2+bx+c=0$$`之根`$$(a\ne0)$$`
![盒图2](http://shu-huai.cn:13127/public/图床/盒图2.png "盒图2")

- PAD图
特点
结构清晰，层次分明，易读；
支持自顶向下、逐步求精的设计思想；
容易将PAD自动转换为高级语言源程序。
![PAD图](http://shu-huai.cn:13127/public/图床/PAD图.png "PAD图")

#### 列表工具

- 判定表
![判定表](http://shu-huai.cn:13127/public/图床/判定表.png "判定表")

- 判定树
![判定树](http://shu-huai.cn:13127/public/图床/判定树.png "判定树")

## 实现

编码和测试统称为实现

### 编码

选择程序设计语言

#### 编码风格

不要牺牲程序的清晰性和可读性来不必要地提高程序的效率。

规则

- 程序内部的文档

- 数据说明

- 语句构造

- 输入输出

- 效率

### 软件测试基础

#### 目标

通过有限个测试用例，尽可能多地发现程序中的错误。

#### 准则

所有测试都应该能追溯到用户需求。

测试开始之前就制定出测试计划。

Pareto原理：80%的错误很可能是20%的模块造成的

从“小规模”测试逐步到“大规模”测试

穷举测试是不可能的

为了达到最佳的测试效果，应该由独立的第三方从事测试工作

#### 方法

黑盒测试又称功能测试或数据驱动测试、白盒测试又称结构测试或逻辑驱动测试

#### 步骤

模块测试

子系统测试

系统测试

验收测试

平行运行

### 白盒测试

#### 测试用例

测试数据和预期的输出结果

最困难的问题是设计测试用的输入数据

选用少量“最有效的”测试数据

#### 逻辑覆盖

以程序内部的逻辑结构为基础的设计测试用例的技术

语句覆盖
至少每个语句应该执行一次

判定覆盖
至少每个语句应该执行一次，每个判定的每个分支至少应该执行一次

条件覆盖
至少每个语句应该执行一次，每个判定的每个条件都取到各种可能的结果

判定/条件覆盖
至少每个语句应该执行一次，每个判定的每个分支至少应该执行一次，每个判定的每个条件都取到各种可能的结果

条件组合覆盖
每个判定表达式中条件的各种可能组合都至少出现一次

点覆盖
相当于语句覆盖

边覆盖
相当于判定覆盖

路径覆盖
每条可能的路径至少执行一次。如有循环至少进入一次

#### 控制结构测试

##### 基本路径测试

步骤

1. 根据过程设计结果画出相应的流图
![基本路径测试1](http://shu-huai.cn:13127/public/图床/基本路径测试1.png "基本路径测试1")

2. 计算流图的环形复杂度
流图中的区域数等于环形复杂度
`$$V(G)=E−N+2$$`,其中，`$$E$$`边数，`$$N$$`是结点数
`$$V(G)=P+1$$`，其中，`$$P$$`是判定结点的数目
![基本路径测试2](http://shu-huai.cn:13127/public/图床/基本路径测试2.png "基本路径测试2")

3. 确定线性独立路径的基本集合
程序的环路复杂性给出了程序基本路径集中的独立路径条数
一条独立路径是至少包含有一条在其它独立路径中从未有过的边的路径
基本路径集
`$$\{1,11\}$$`
`$$\{1,2,3,4,5,10,1,11\}$$`
`$$\{1,2,3,6,8,9,10,1,11\}$$`
`$$\{1,2,3,6,7,9,10,1,11\}$$`

4. 设计可强制执行基本集合中每条路径的测试用例。

##### 条件测试

##### 循环测试

专注于测试循环结构的有效性

- 简单循环
跳过循环
通过循环一次
通过循环两次
通过循环m次
通过循环n−1，n，n+1次

- 嵌套循环
由内而外简单循环

- 串接循环
循环独立时使用简单循环，循环不独立时使用嵌套循环

### 黑盒测试

#### 等价划分

步骤

1. 形成等价类表，每一等价类规定一个唯一的编号

2. 设计一测试用例，使其尽可能多地覆盖尚未覆盖的有效等价类，重复这一步骤，直到所有有效等价类均被测试用例所覆盖

3. 设计一新测试用例，使其只覆盖一个无效等价类，重复这一步骤直到所有无效等价类均被覆盖

#### 边界值分析

边界值分析是对等价类分析的补充，两者结合使用

![边界值分析](http://shu-huai.cn:13127/public/图床/边界值分析.png "边界值分析")

步骤

1. 每次保留一个变量，让其余的变量取正常值，被保留的变量依次取刚好等于、刚刚小于和刚刚大于边界值

2. 对其它每个变量重复

#### 错误推测

列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例。

### 单元测试

#### 测试重点

模块接口、局部数据结构、重要的执行通路、出错处理通路、边界条件

#### 代码审查

#### 计算机测试

驱动程序
“主程序”
接收测试数据，印出有关的结果

存根程序
模拟被测模块的子模块
少量的数据操作，印出对入口的检验或操作结果

### 集成测试

#### 非渐增式集成

分别测试每个模块，按设计一次性集成

#### 渐增式集成

逐步把下一被测模块同已测好的那些模块进行集成

自顶向下测试
从主控制模块开始，沿着程序的控制层次向下移动，逐渐把各个模块结合起来
优点

- 存根不浪费，可以扩展成相应的实际模块

- 用深度优先方法，可以在早期实现软件的一个完整的功能

- 能够在早期发现主要控制或关键抉择的问题

- 错误隔离

缺点

- 可复用模块（最可能是底层模块）测试不充分

- 产品设计得越好，模块的测试可能越不彻底

自底向上测试
从原子模块开始组装和测试
优点

- 操作模块得到充分测试

- 测试次数增加

- 操作模块被驱动模块调用，而不是被屏蔽错误的“保护编程”的上层模块调用

- 错误隔离

问题

- 主要设计错误较晚被检测

三明治式测试
逻辑模块自顶向下实现与集成 ，操作模块自底往上实现与集成，最后两组的接口被测试
优点

- 错误隔离

- 能较早的发现设计缺陷

- 操作模块得到成分测试，可以信任的复用

回归测试
重新执行测试集的子集
保证变化没有带来非预期的副作用。

### 验收测试

Alpha测试：用户在开发者的指导下测试

Beta测试：用户在实际使用环境下进行测试

### 调试

#### 任务

1. 确定程序中可疑错误的确切性质和位置。

2. 对程序进行修改，排除这个错误。

#### 困难

- 症状和产生症状的原因可能在程序中相距甚远。

- 当改正了另一个错误之后，症状可能暂时消失了。

- 症状可能实际上并不是由错误引起的（如舍入误差）。

- 症状可能是由不易跟踪的人为错误引起的。

- 症状可能是由定时问题引起的。

- 可能很难重新产生完全一样的输入条件（例如，输入顺序不确定的实时应用系统）。

- 症状可能时有时无，这种情况在硬件和软件紧密地耦合在一起的嵌入式系统中特别常见。

- 症状可能是由分布在许多任务中的原因引起的，这些任务运行在不同的处理机上。

#### 原则

确定错误的性质和位置的原则

- 用头脑去分析思考与错误征兆有关的信息。

- 避开死胡同。

- 只把调试工具当做辅助手段来使用。

- 避免用试探法。

修改错误的原则

- 在出现错误的地方，很可能还有别的错误。

- 只修改了这个错误的征兆或这个错误的表现，而没有修改错误的本身。

- 当心修正一个错误的同时有可能会引入新的错误。

- 修改错误的过程将迫使人们暂时回到程序设计阶段

#### 方法

- 蛮干法
利用调试工具
显示指定内存单元和变量的值
设置指定的内存单元与变量的值
单步执行方式、设立断点方式

- 回溯法

- 原因排除法
对分查找法
归纳法
演绎法
