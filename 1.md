# 编译原理

## 引论

### 什么是编译程序

从基本功能来看，编译程序（Compiler）是一种翻译程序（Translator）

将语言A的程序翻译为语言B的程序，称语言A为源语言（Source Language），称语言B为目标语言（Target Language）

### 编译过程和简易程序的结构

#### 编译程序的逻辑结构

- 两大阶段

  分析、综合

- 三大端

  前端、中端、后端

- 逻辑过程

  ![逻辑过程](http://shu-huai.cn:13127/public/图床/逻辑过程.png "逻辑过程")

- 词法分析

  扫描源程序字符流，识别出有词法意义的单词，返回单词的类别和单词的值，或词法错误信息

  例
  ![词法分析1](http://shu-huai.cn:13127/public/图床/词法分析1.png "词法分析1")
  ![词法分析2](http://shu-huai.cn:13127/public/图床/词法分析2.png "词法分析2")

- 语法分析

  在词法分析的基础上将单词序列分解成各类语法短语，可表示成语法树。

  例
  ![语法分析](http://shu-huai.cn:13127/public/图床/语法分析.png "语法分析")

- 语义分析

  对语法分析后的程序进行语义分析，不符合语义规则时给出语义错误信息。

  例
  ![语义分析](http://shu-huai.cn:13127/public/图床/语义分析.png "语义分析")

- 符号表

  收集每个名字的各种属性用于语义分析及后续各阶段。

  例
  ![符号表](http://shu-huai.cn:13127/public/图床/符号表.png "符号表")

- 出错处理

- 检查错误：报告出错信息（error reporting）

- 排错：恢复编译工作（error recovery）

- 中间代码生成

- 目标代码生成

  把中间代码变换成特定机器上的绝对指令代码或可重定位的指令代码或汇编指令代码

#### 编译程序的组织

- 编译程序的遍

  对一种代码形式从头到尾扫描一遍，将一个代码空间变换到另一个代码空间

  代码空间=代码+符号表+其他有用信息

### 编译程序的伙伴程序

#### 解释程序

- 不产生目标程序文件
- 不区别翻译阶段和执行阶段
- 翻译源程序的每条语句后直接执行
- 程序执行期间一直有解释程序守候
- 常用于实现虚拟机
- 和编译程序的关系
  ![和编译程序的关系1](http://shu-huai.cn:13127/public/图床/和编译程序的关系1.png "和编译程序的关系1")

#### 预处理程序

- 支持宏定义（Macro definition）
  如C源程序中#define行的处理
- 支持文件包含（File inclusion）
  如C源程序中#include行的处理
- 支持其他更复杂的源程序扩展信息
- 和编译程序的关系
  ![和编译程序的关系2](http://shu-huai.cn:13127/public/图床/和编译程序的关系2.png "和编译程序的关系2")

#### 汇编程序

翻译汇编语言程序至可重定位的（Relocatable）机器语言程序

#### 装入和连接程序

装入程序对可重定位机器语言程序进行修改

连接程序合并多个可重定位机器语言程序文件到同一个程序

和编译程序的关系
  ![和编译程序的关系3](http://shu-huai.cn:13127/public/图床/和编译程序的关系3.png "和编译程序的关系3")

#### 调试程序

- 功能
  反馈目标程序运行时的信息
  将目标程序运行时信息与源程序关联
  断点管理、单步跟踪、读/写目标及状态等功能
- 与编译程序的关系
  ![和编译程序的关系4](http://shu-huai.cn:13127/public/图床/和编译程序的关系4.png "和编译程序的关系4")

## 文法和语言

### 文法

文法是以有穷集合刻画无穷集合的一个工具

用产生式进行语法的描述

推导的过程是从开始符号出发，不断选择产生式来进行替换

### 符号和符号串

字母表：元素的非空有穷集合，字母表中的元素称为符号

符号串：由字母表中的符号组成的任何有穷序列

符号串的长度：符号串中符号的个数，$|S|$

空符号串：$\varepsilon$，不包含任何符号的符号串

符号串的头、尾、固有头、固有尾

- 设符号串$z=abc$
- 头：$\varepsilon$、$a$、$ab$、$abc$
- 尾：$\varepsilon$、$c$、$bc$、$abc$
- 固有头：$\varepsilon$、$a$、$ab$
- 固有尾：$\varepsilon$、$c$、$bc$

符号串的连接：把一个符号串写在另一个符号串之后

符号串的方幂：把自身连接$n$次

符号串的集合：符号串组成的集合

集合的乘积：$AB=\\{xy|x\inA,y\inB\\}$

字母表的闭包：$\Sigma^∗$表示字母表$\Sigma$上所有有穷长的串的集合
$\Sigma^∗=\Sigma^0\cup\Sigma^1\cup\cdots\cup\Sigma^n$

字母表的正闭包：$\Sigma^+=\Sigma^1\cup\Sigma^2\cup\cdots\cup\Sigma^n$

### 文法和语言的形式定义

 规则
  也称重写规则、产生式、生成式
  形如$\alpha\rightarrow\beta$或$\alpha∷=\beta$的有序对，其中$\alpha$是规则的左部，是某字母表$V$的正闭包$V^+$中的一个符号，$\beta$是$V^∗$中的一个符号，是规则的右部
 文法的定义
  四元组$(V_N,V_T,P,S)$，终结符集、非终结符集、产生式集、开始符号
  $V_N\cap V_T=\emptyset$，$V_N\cup V_T=V$，$S\in V_N$
 直接推导
  $v=\gamma\alpha\delta$，$w=\gamma\beta\delta$，$\alpha\rightarrow\beta$，则$v\Rightarrow w$
 推导
  $v\Rightarrow w_0\Rightarrow w_1\Rightarrow\cdots\Rightarrow w$，记为$v\Rightarrow\stackrel{+}w$
  $v\Rightarrow┴+ w$或$v\Rightarrow w$，则v\Rightarrow┴∗ w
 句型、句子
  S\Rightarrow┴∗ x，则x为句型，若此时x\inV_T^∗，则x为句子
 语言
  一个文法的一切句子的集合
 文法等价
  若两个文法生成的语言是相等的，这两个文法等价

### 文法的类型

 0型文法——短语文法：对任意产生式\alpha\rightarrow\beta，都有\alpha,\beta\in(V_N\cupN_T )^∗，且\alpha至少含有一个非终结符
 1型文法——上下文有关文法：对任意产生式\alpha\rightarrow\beta，都有|\beta|≥|\alpha|，仅仅S\rightarrow\varepsilon除外
 2型文法——上下文无关文法：对任意产生式\alpha\rightarrow\beta，都有\alpha\inV_N，且\beta\in(V_N\cupV_T )^∗
 3型文法——正规文法：任意产生式的形式都为A\rightarrow\alphaB或A\rightarrow\alpha，其中A\inV_N，B\inV_N，\alpha\inV_T^∗

### 上下文无关文法及其推导树

 上下文无关文法有能力描述现今程序设计语言的语法结构
 语法树：句型的语法树
  每个节点都有一个标记，此标记是V的一个符号
  根的标记是S
  若一个结点至少有一个它自己除外的子孙，则它代表的标记肯定在V_N 中
  从结点到结点代表的标记的直接子孙从左到右构成的串构成一个P的产生式
  最左（最右）推导：对最左（最右）非终结符进行替换
  最右推导是规范推导，由规范推导得到的句型是规范句型
  例

  给定文法G=(V_N,V_T,P,S)，对于G的任何句型都能构造与之关联的语法树
  G为上下文无关文法，对于\alpha≠\varepsilon，有S\rightarrow┴∗ \alpha，当且仅当文法G有以\alpha为结果的一棵语法树
  一个句型对应的语法树不一定是唯一的，对应的最左（最右）推导也不一定是唯一的
  文法的二义性
   若一个文法存在某个句子对应两棵不同的语法树，则称这个文法是二义的，或者，若一个文法存在某个句子有两个不同的最左（右）推导，则称这个文法是二义的
   某些二义文法可以适当改写产生式，变为非二义文法
  语言的二义性
   如果产生上下文无关语言的每一个文法都是二义的，则说此语言是先天二义的

### 句型的分析

 句型的分析就是识别一个符号串是否为某文法的句型，即，是否为语法上正确的过程
 分析算法
  自上而下分析法
   是从文法的开始符号出发，反复使用各种产生式，寻找“匹配”于输入符号串的推导
  自下而上分析法
   从输入符号串开始，逐步进行“归约”，直至归约到文法的开始符号（S）
 句型分析的有关问题
  可归约串
   当前串中可以归约到某个非终结符的子串
  文法G[S]，\alpha\beta\delta是文法G的一个句型
   句型的短语
    S\Rightarrow┴∗ \alphaA\delta且A\Rightarrow┴+ \beta，则称\beta是句型\alpha\beta\delta相对于非终结符A的短语
   句型的直接短语
    若有A\Rightarrow\beta，则称\beta是句型\alpha\beta\delta相对于非终结符A的直接短语
   句型的句柄
    一个句型的最左直接短语称为该句型的句柄
  从语法树中找出短语、直接短语和句柄
   一棵子树的所有叶子结点自左至右排列起来，形成此句型相对于该子树树根的短语
   语法树中只有父子两代的所有叶子结点自左至右排列起来，形成此句型相对于该子树树根的直接短语
   语法树中最左边的那棵只有父子两代的子树的所有叶子结点自左至右排列起来，就是此句型的句柄

### 有关文法实际应用中的一些说明

 有关文法的实用限制
  有害规则
   形如U\rightarrowU的产生式
    会引起文法的二义性
  多余规则
   文法中连一个句子的推导都用不到的规则
   不可到达的非终结符
    不在任何规则的右部出现的非终结符
   不可终止的非终结符
    不能从它推出终结符号串的非终结符
  对于文法G[S]，为了保证任一非终结符A在句子推导中出现，必须满足如下两个条件
   A必须在某句型中出现，即有S\Rightarrow┴∗ \alphaA\beta，其中\alpha,\beta\inV^*
   必须能够从A推出终结符号串t来，即A\Rightarrow┴+ t，其中t\inV_T^*
 上下文无关文法中的\varepsilon规则
  形式A\rightarrow \varepsilon，称这种规则为\varepsilon规则。
  因为\varepsilon规则会使得有关文法的一些讨论和证明变得复杂,有时会限制这种规则的出现。
  文法构思的启示是要找出语言的有穷描述，而如果语言L有一个有穷的描述，则L1=L\cup{\varepsilon}也同样有一个有穷的描述
  可以证明，若L是上下文有关语言、上下文无关语言或正规语言，则L\cup{\varepsilon}和L−{\varepsilon}分别是上下文有关语言、上下文无关语言和正规语言
